Modules in the radioPlayer are quite simple.

First of all, ther are in total only 4 modules:
- Observer (PlayerModule), this module is a passive observer, you can use this as a status api or to send the song metadata to your RDS encoder
- Modifier (PlaylistModifierModule), module which intercepts the playlist before playing and replaced it, this module can shuffle the playlist, insert jingles or intros and outros
- (!) Advisor (PlaylistAdvisor), this module is very important and is required to run and there can be only one of these in a core session. It is responsible for picking the playlist file itself as in a file path. This can be a scheduler, or just a constant
- Active modifier (ActiveModifier), this module is optional, but there can still be only one. This module can replace the track while playing, allowing you to skip tracks or play tracks on demand, it can also extend the playlist

```python
@dataclass
class Track:
    path: str
    fade_out: bool
    fade_in: bool
    official: bool
    args: dict[str, str] | None
    offset: float = 0.0

@dataclass
class Process:
    process: Popen
    track: str
    started_at: float
    duration: float

class Skeleton_ProcessManager:
    processes: list[Process]
    def _get_audio_duration(self, file_path): ...
    def play(self, track_path: str, fade_in: bool=False, fade_out: bool=False, fade_time: int=5, offset: float=0.0) -> Process: ...
    def anything_playing(self) -> bool: ...
    def stop_all(self, timeout: float | None = None) -> None: ...
    def wait_all(self, timeout: float | None = None) -> None: ...
class BaseIMCModule:
    """
    This is not a module to be used but rather a placeholder IMC api to be used in other modules
    """
    def imc(self, imc: 'InterModuleCommunication') -> None:
        """
        Receive an IMC object
        """
        self._imc = imc
    def imc_data(self, source: 'BaseIMCModule', source_name: str | None, data: object, broadcast: bool) -> object:
        """
        React to IMC data
        """
        return None

class ProcmanCommunicator(BaseIMCModule):
    def __init__(self, procman: Skeleton_ProcessManager) -> None:
        self.procman = procman
    def imc(self, imc: 'InterModuleCommunication') -> None:
        super().imc(imc)
        self._imc.register(self, "procman")
    def imc_data(self, source: BaseIMCModule, source_name: str | None, data: object, broadcast: bool) -> object:
        if broadcast: return
        if isinstance(data, str) and data.lower().strip() == "raw": return self.procman
        elif isinstance(data, dict):
            op = data.get("op")
            if not op: return
            if int(op) == 0: return {"op": 0, "arg": "pong"}
            elif int(op) == 1:
                if arg := data.get("arg"):
                    return {"op": 1, "arg": self.procman._get_audio_duration(arg)}
                else: return
            elif int(op) == 2:
                self.procman.stop_all(data.get("timeout", None))
                return {"op": 2}
            elif int(op) == 3:
                return {"op": 3, "arg": self.procman.processes}

class PlayerModule(BaseIMCModule):
    """
    Simple passive observer, this allows you to send the current track the your RDS encoder, or to your website
    """
    def on_new_playlist(self, playlist: list[Track]) -> None:
        """This is called every new playlist"""
        pass
    def on_new_track(self, index: int, track: Track) -> None:
        """
        Called on every track including the ones added by the active modifier, you can check for that comparing the playlists[index] and the track
        """
        pass
    def progress(self, index: int, track: Track, elapsed: float, total: float, real_total: float) -> None:
        """
        Real total and total differ in that, total is how much the track lasts, but real_total will be for how long we will play it for
        Runs at a frequency around 1 Hz
        Please don't put any blocking or code that takes time
        """
        pass
class PlaylistModifierModule:
    """
    Playlist modifier, this type of module allows you to shuffle, or put jingles into your playlist
    """
    def modify(self, global_args: dict, playlist: list[Track]) -> list[Track] | None:
        """
        global_args are playlist global args (see radioPlayer_playlist_file.txt)
        """
        return playlist
    # No IMC, as we only run on new playlists
class PlaylistAdvisor(BaseIMCModule):
    """
    Only one of a playlist advisor can be loaded. This module picks the playlist file to play, this can be a scheduler or just a static file
    """
    def advise(self, arguments: str | None) -> str | None:
        """
        Arguments are the arguments passed to the program on startup
        """
        return "/path/to/playlist.txt"
    def new_playlist(self) -> bool:
        """
        Whether to play a new playlist, if this is True, then the player will refresh and fetch a new playlist, calling advise
        """
        return False
class ActiveModifier(BaseIMCModule):
    """
    This changes the next song to be played live, which means that this picks the next song, not the playlist, but this is affected by the playlist
    """
    def arguments(self, arguments: str | None) -> None:
        """
        Called at start up with the program arguments
        """
        pass
    def play(self, index:int, track: Track) -> tuple[Track, bool] | tuple[None, None]:
        """
        Returns a tuple, in the first case where a is the track and b is a bool, b corresponds to whether to extend the playlist, set to true when adding content instead of replacing it
        When None, None is returned then that is treated as a skip, meaning the core will skip this song
        """
        return track, False
    def on_new_playlist(self, playlist: list[Track]) -> None:
        """
        Same behaviour as the basic module function
        """
        pass
class InterModuleCommunication:
    def __init__(self, modules: Sequence[BaseIMCModule | None]) -> None:
        self.modules = modules
        self.names_modules: dict[str, BaseIMCModule] = {}
        for module in modules: 
            if module: module.imc(self)
    def broadcast(self, source: BaseIMCModule, data: object) -> None:
        """
        Send data to all modules, other than ourself
        """
        source_name = next((k for k, v in self.names_modules.items() if v is source), None)
        for module in [f for f in self.modules if f is not source]: 
            if module: module.imc_data(source, source_name, data, True)
    def register(self, module: BaseIMCModule, name: str) -> bool:
        """
        Register our module with a name, so we can be sent data via the send function
        """
        if name in self.names_modules.keys(): return False
        self.names_modules[name] = module
        return True
    def send(self, source: BaseIMCModule, name: str, data: object) -> object:
        """
        Sends the data to a named module, and return its response
        """
        if not name in self.names_modules.keys(): raise Exception
        return self.names_modules[name].imc_data(source, next((k for k, v in self.names_modules.items() if v is source), None), data, False)
```

Each module shall have a python script in the modules directory. Each of the modules need to define one or more global variables in order to be seen by the core:
- module (list['PlayerModule'] or 'PlayerModule'), this shall be just the list or one passive observer class
- playlistmod ('PlaylistModifierModule', list['PlaylistModifierModule'], tuple['PlaylistModifierModule' | list['PlaylistModifierModule'], int]), module itself, list of modules or the module itself and list of them with an index integer which sets the order of modifiers (0 is first)
- advisor ('PlaylistAdvisor')
- activemod ('ActiveModifier')

NEW! The procman communicator allows you to get the track duration, but also STOP WHATEVER IS PLAYING! That means we can skip tracks WHILE THEY ARE PLAYING