import random
from . import log95, PlaylistModifierModule, Track, Path

# The module loader injects this variable.
# We assert it to satisfy static analysis and inform runtime about its presence.
_log_out: log95.TextIO
assert _log_out # pyright: ignore[reportUnboundVariable]

def load_play_counts(file_path: Path) -> dict[str, int]:
    """
    Loads the play counts from the file generated by the play_counter module.
    """
    counts = {}
    try:
        with open(file_path, 'r') as file:
            for line in file:
                if line.strip() == "" or line.startswith(";"):
                    continue
                try:
                    key, value = line.split(':', 1)
                    counts[key.strip()] = int(value.strip())
                except ValueError:
                    # Ignore lines with invalid formats
                    continue
        return counts
    except FileNotFoundError:
        # It's okay if the file doesn't exist yet, means no counts have been recorded.
        return {}

class PopularitySorterModule(PlaylistModifierModule):
    """
    A playlist modifier that reorders tracks based on their play history.
    For every pair of tracks, it gives a 60% probability to schedule the less-played track first.
    """
    def __init__(self) -> None:
        self.logger = log95.log95("PopSort", output=_log_out)
        # The play_counter file is located in the parent directory of the 'modules' folder.
        self.play_counts_file = Path(__file__, "..", "..", "play_counter").resolve()

    def modify(self, global_args: dict, playlist: list[Track]) -> list[Track]:
        self.logger.info("Applying popularity-based sorting to the playlist...")
        
        play_counts = load_play_counts(self.play_counts_file)
        if not play_counts:
            self.logger.info("Play counter file not found or is empty. No sorting will be applied.")
            return playlist

        # We will iterate through the playlist, looking at two tracks at a time.
        i = 0
        while i < len(playlist) - 1:
            track1 = playlist[i]
            track2 = playlist[i+1]

            if not (track1.official and track2.official): 
                i += 2
                continue

            # Get play counts for both tracks, defaulting to 0 if not found.
            count1 = play_counts.get(track1.path.as_posix(), 0)
            count2 = play_counts.get(track2.path.as_posix(), 0)

            # Determine if the first track in the pair has been played less or an equal number of times.
            is_track1_less_played = count1 <= count2

            # With a 60% chance, we want the less popular song to come first.
            if random.random() < 0.6:
                # If the more popular song is currently first, swap them.
                if not is_track1_less_played:
                    playlist[i], playlist[i+1] = track2, track1
            # With a 40% chance, we want the more popular song to come first.
            else:
                # If the less popular song is currently first, swap them.
                if is_track1_less_played:
                    playlist[i], playlist[i+1] = track2, track1
            
            # Move to the next pair of tracks.
            i += 2

        self.logger.info("Popularity sorting complete.")
        return playlist

# The radioPlayer will look for a 'playlistmod' variable to load the module.
playlistmod = (PopularitySorterModule(), 2)